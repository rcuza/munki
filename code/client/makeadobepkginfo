#!/usr/bin/python
# encoding: utf-8
#
# Copyright 2009 Greg Neagle.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#      http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
makeadobepkginfo

Created by Greg Neagle on 2009-10-19.
Creates a managed install pkg info plist given a dmg with
an Adobe CS4 Deployment Toolkit package and installation media.

You should also pass paths to the apps installed by the package. These
are added to the 'installs' key of the catalog item plist and are used when 
processing the catalog to check if the package needs to be installed or 
reinstalled.

The generated plist is printed to STDOUT.

Usage: makeadobepkginfo /path/to/package_or_dmg [-f /path/to/item/it/installs ...]
"""

import sys
import os
import re
import optparse
from distutils import version
import subprocess

from munkilib import munkicommon
from munkilib import FoundationPlist
from munkilib import adobeutils


def getBundleInfo(path):
    """
    Returns Info.plist data if available
    for bundle at path
    """
    infopath = os.path.join(path, "Contents", "Info.plist")
    if not os.path.exists(infopath):
        infopath = os.path.join(path, "Resources", "Info.plist")
        
    if os.path.exists(infopath):
        try:
            pl = FoundationPlist.readPlist(infopath)
            return pl
        except:
            pass

    return None


def getappinfo(itempath):
    """
    Gets info for an app passed to makeadobepkginfo, to be used for
    the "installs" key.
    """
    infodict = {}
    if itempath.endswith('.app'):
        infodict['type'] = 'application'
        infodict['path'] = itempath
        pl = getBundleInfo(itempath)
        if 'CFBundleName' in pl:
            infodict['CFBundleName'] = pl['CFBundleName']
        if 'CFBundleIdentifier' in pl:
            infodict['CFBundleIdentifier'] = pl['CFBundleIdentifier']
        if 'CFBundleShortVersionString' in pl:
            infodict['CFBundleShortVersionString'] = pl['CFBundleShortVersionString'].split()[0]
        elif 'CFBundleVersion' in pl:
            infodict['CFBundleShortVersionString'] = pl['CFBundleVersion'].split()[0]
        if 'LSMinimumSystemVersion' in pl:
            infodict['minosversion'] = pl['LSMinimumSystemVersion']
        elif 'SystemVersionCheck:MinimumSystemVersion' in pl:
            infodict['minosversion'] = pl['SystemVersionCheck:MinimumSystemVersion']
        
    return infodict
    

def getPackageInfoFromAdobeDmg(dmgpath, pkgname):
    # gets catalog info from the Adobe dmg
    info = None
    try:
        mountpoints = munkicommon.mountdmg(dmgpath)
        if mountpoints:
            mountpoint = mountpoints[0]
            installroot = os.path.join(mountpoint, pkgname)
            adobeinstallxml = os.path.join(installroot, "AdobeUberInstaller.xml")
            if os.path.exists(adobeinstallxml):
                info = adobeutils.getAdobePackageInfo(installroot)
            munkicommon.unmountdmg(mountpoint)
    except:
        pass
    return info
       
    
def findAdobeSetupApp(dmgpath):
    try:
        mountpoints = munkicommon.mountdmg(dmgpath)
        if mountpoints:
            setuppath = adobeutils.findSetupApp(mountpoints[0])
            munkicommon.unmountdmg(mountpoints[0])
            return setuppath
    except:
        return ''
    
    
def main():
    usage = "usage: %prog [options] /path/to/adobeinstaller.dmg"
    p = optparse.OptionParser(usage=usage)
    p.add_option('--pkgname', '-p',
                    help='Name of an Adobe CS4 Deployment Toolkit installer package folder at the top level of the mounted dmg.\n \
                    If this flag is missing, the AdobeUser files should be at the top level of the mounted dmg.')
    p.add_option('--app', '-a', action="append",
                    help='Path to a primary Adobe CS4 app installed by this package. Can be specified multiple times.')
    p.add_option('--uninstallerdmg', '-u',
                    help='Path to a disk image containing an AdobeUberUninstaller for this item.')
    options, arguments = p.parse_args()
    if len(arguments) == 0:
        print >>sys.stderr, "Need to specify an Adobe installer .dmg!"
        exit(-1)
    
    if len(arguments) > 1:
        print >>sys.stderr, "Can process only one installer item at a time. Ignoring additional installer items."
        
    item = arguments[0].rstrip("/")
    if os.path.exists(item) and item.endswith('.dmg'):
        catinfo = {}
        pkgname = ""
        if options.pkgname:
            pkgname = options.pkgname
        mountpoints = munkicommon.mountdmg(item)
        if mountpoints:
            adobeinstallxml = os.path.join(mountpoints[0], pkgname, "AdobeUberInstaller.xml")
            if os.path.exists(adobeinstallxml):
                # this is a CS4 Enterprise Deployment package
                catinfo = getPackageInfoFromAdobeDmg(item, pkgname)
                if catinfo:
                    catinfo['uninstallable'] = True
                    catinfo['uninstall_method'] = "AdobeUberUninstaller"
                    catinfo['installer_type'] = "AdobeUberInstaller"
            munkicommon.unmountdmg(mountpoints[0])
            
        else:
            # maybe it's an Adobe updater?
            setuppath = findAdobeSetupApp(item)
            if setuppath:
                # seems to be an Adobe Updater
                setupapp = "/Setup.app/Contents/MacOS/Setup"
                # get the parent directory of Setup.app
                try:
                    pkgdir = setuppath[0:-len(setupapp)]
                    pkgname = os.path.basename(pkgdir)
                except:
                    pkgname = os.path.basename(item)
                catinfo['display_name'] = pkgname
                catinfo['description'] = "Adobe Updater package."
                catinfo['uninstallable'] = False
                catinfo['installer_type'] = "AdobeSetup"
                catinfo['modifies'] = ["PleaseEditMe-1.0.0"]
        
        if not catinfo:
            print >>sys.stderr, "Could not find a supported installer item in %s!" % item
            exit(-1)
            
        # get size of installer item
        itemsize = int(os.path.getsize(item))
        catinfo['installer_item_size'] = int(itemsize/1024)
        catinfo['installed_size'] = int(itemsize/1024)

        catinfo['name'] = catinfo['display_name'].replace(" ",'')
        minosversion = ""
        if options.app:
            installs = []           
            for appitem in options.app:
                # no trailing slashes, please.
                appitem = appitem.rstrip('/')
                if os.path.exists(appitem):
                    iteminfodict = getappinfo(appitem)
                    # no receipt version, so grab an app version
                    if not 'version' in catinfo:
                        if 'CFBundleShortVersionString' in iteminfodict:
                            catinfo['version'] = iteminfodict['CFBundleShortVersionString']
                    if 'minosversion' in iteminfodict:
                        thisminosversion = iteminfodict.pop('minosversion')
                        if not minosversion:
                            minosversion = thisminosversion
                        elif version.LooseVersion(thisminosversion) < version.LooseVersion(minosversion):
                            minosversion = thisminosversion
                    installs.append(iteminfodict)
                else:
                    print >>sys.stderr, "Item %s doesn't exist. Skipping." % appitem
            catinfo['installs'] = installs   
        
        if not 'version' in catinfo:
            catinfo['version'] = "1.0.0.0.0 (Please edit me!)"
               
        # try to generate the correct item location
        temppath = item
        location = ""
        while len(temppath) > 4:
            if temppath.endswith('/pkgs'):
                location = item[len(temppath)+1:]
                break
            else:
                temppath = os.path.dirname(temppath)
                
        if not location:
            #just the filename
            location = os.path.split(item)[1]
        catinfo['installer_item_location'] = location
        
        if minosversion:
            catinfo['minimum_os_version'] = minosversion
        else:
            catinfo['minimum_os_version'] = "10.4.0"
        
        if options.uninstallerdmg:
            uninstallerpath = options.uninstallerdmg
            if os.path.exists(uninstallerpath):
                # try to generate the correct item location
                temppath = uninstallerpath
                location = ""
                while len(temppath) > 4:
                    if temppath.endswith('/pkgs'):
                        location = uninstallerpath[len(temppath)+1:]
                        break
                    else:
                        temppath = os.path.dirname(temppath)

                if not location:
                    #just the filename
                    location = os.path.split(uninstallerpath)[1]
                catinfo['uninstaller_item_location'] = location
                itemsize = int(os.path.getsize(uninstallerpath))
                catinfo['uninstaller_item_size'] = int(itemsize/1024)
            else:
                print >>sys.stderr, "No uninstaller at %s" % uninstallerpath
            
        # some metainfo
        catinfo['catalogs'] = ['testing']
        
        # and now, what we've all been waiting for...
        print FoundationPlist.writePlistToString(catinfo)


if __name__ == '__main__':
	main()

